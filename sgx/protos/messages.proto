syntax = "proto3";

package oram;

import "google/protobuf/empty.proto";

// This defines all the functionalies that a remote server should provide.
// Currently we only support read / write. This ORAM data are generated by the server at random.
// If you need to upload data to the server, you should define other interfaces.
service sgx_oram {
  // ===================================================== //
  // Enclave-related remote process calls.
  rpc init_enclave(InitRequest) returns (InitReply) {}

  rpc init_oram(OramInitRequest) returns (google.protobuf.Empty) {}
  // ===================================================== //

  rpc generate_session_key(InitRequest) returns (InitReply) {}

  // ===================================================== //
  // Functions for remote attestation and key derivation.
  // FIXME: possibly error-prone :(.
  rpc remote_attestation_begin(InitialMessage) returns (Message0) {}

  rpc remote_attestation_msg0(Message0) returns (Message1) {}

  rpc remote_attestation_msg2(Message2) returns (Message3) {}

  rpc remote_attestation_final(AttestationMessage) returns (google.protobuf.Empty) {}
  // ===================================================== //

  rpc read_block(ReadRequest) returns (ReadReply) {}

  rpc write_block(WriteRequest) returns (WriteReply) {}

  rpc close_connection(CloseRequest) returns (google.protobuf.Empty) {}
}

message InitRequest {
  // The round variable indicates the current phase of the key negotiation.
  int32 round = 1;
  bytes content = 2;
}

message InitReply {
  bool success = 1;

  // Shared session key for symmetric encryption.
  // This is done by SGX's remote attestation procedure.
  // This field is valid iff. the negotiation finishes.
  // This is also used in remote attestation.
  bytes content = 2;
}

message OramInitRequest {
  uint32 way = 1;
  uint32 number = 2;
  uint32 bucket_size = 3;
  uint32 type = 4;
  uint32 constant = 5;
  uint32 round = 6;
  // If oram_type = 1, then the server should initialize SO2 (by default);
  // otherwise it should initialize the TPORAM.
  optional uint32 oram_type = 7;
  optional bytes verification = 8;
  // The initial permutation vector.
  repeated uint32 permutation = 9;
}

message ReadRequest {
  uint32 address = 1;
}

message ReadReply {
  bytes data = 1;
  bool success = 2;
}

message WriteRequest {
  uint32 address = 1;
  bytes data = 2;
}

message WriteReply {
  bool success = 1;
}

message CloseRequest {
}

message InitialMessage {
	uint32 type = 1;
	optional uint32 size = 2;
}

message Message0 {
	uint32 type = 1;
	uint32 epid = 2;
	optional uint32 status = 3;
}

message Message1 {
	uint32 type = 1;
	repeated uint32 GaX = 2 [packed=true];
	repeated uint32 GaY = 3 [packed=true];
	repeated uint32 GID = 4 [packed=true];
}

message Message2 {
	uint32 type = 1;
	optional uint32 size = 2;
	repeated uint32 public_key_gx = 3 [packed=true];
	repeated uint32 public_key_gy = 4 [packed=true];
	optional uint32 quote_type = 5;
	repeated uint32 spid = 6 [packed=true];
	optional uint32 cmac_kdf_id = 7;
	repeated uint32 signature_x = 8 [packed=true];
	repeated uint32 signature_y = 9 [packed=true];
	repeated uint32 smac = 10 [packed=true];
	optional uint32 size_sigrl = 11;
	repeated uint32 sigrl = 12 [packed=true];
}

message Message3 {
	uint32 type = 1;
	optional uint32 size = 2;
	repeated uint32 sgx_mac = 3 [packed=true];
	repeated uint32 gax_msg3 = 4 [packed=true];
	repeated uint32 gay_msg3 = 5 [packed=true];
	repeated uint32 sec_property = 6 [packed=true];
	repeated uint32 quote = 7 [packed=true];
}

message AttestationMessage {
	uint32 type = 1;
	uint32 size = 2;

	optional uint32 epid_group_status = 3;
	optional uint32 tcb_evaluation_status = 4;
	optional uint32 pse_evaluation_status = 5;
	repeated uint32 latest_equivalent_tcb_psvn = 6 [packed=true];
	repeated uint32 latest_pse_isvsvn = 7 [packed=true];
	repeated uint32 latest_psda_svn = 8 [packed=true];
	repeated uint32 performance_rekey_gid = 9 [packed=true];
	repeated uint32 ec_sign256_x = 10 [packed=true];
	repeated uint32 ec_sign256_y = 11 [packed=true];
	repeated uint32 mac_smk = 12 [packed=true];

	optional uint32 result_size = 13;
	repeated uint32 reserved = 14 [packed=true];
	repeated uint32 payload_tag = 15 [packed=true];
	repeated uint32 payload = 16 [packed=true];
}